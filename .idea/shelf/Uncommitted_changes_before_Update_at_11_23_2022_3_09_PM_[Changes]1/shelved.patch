Index: src/ChessGame.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import javax.swing.plaf.synth.SynthDesktopIconUI;\r\nimport java.awt.*;\r\n\r\npublic class ChessGame {\r\n    public static Piece[][] all = new Piece[2][16];\r\n    public static int[] selectedTile = new int[2];\r\n    public static boolean mousePressed = false;\r\n    public static boolean selected = false;\r\n    public static void main(String[] args) {\r\n        Board.init();\r\n        Pawn whitePawn1 = new Pawn(1,2,true);\r\n        Pawn whitePawn2 = new Pawn(2,2,true);\r\n        Pawn whitePawn3 = new Pawn(3,2,true);\r\n        Pawn whitePawn4 = new Pawn(4,2,true);\r\n        Pawn whitePawn5 = new Pawn(5,2,true);\r\n        Pawn whitePawn6 = new Pawn(6,2,true);\r\n        Pawn whitePawn7 = new Pawn(7,2,true);\r\n        Pawn whitePawn8 = new Pawn(8,2,true);\r\n        Pawn blackPawn1 = new Pawn(1,7,false);\r\n        Pawn blackPawn2 = new Pawn(2,7,false);\r\n        Pawn blackPawn3 = new Pawn(3,7,false);\r\n        Pawn blackPawn4 = new Pawn(4,7,false);\r\n        Pawn blackPawn5 = new Pawn(5,7,false);\r\n        Pawn blackPawn6 = new Pawn(6,7,false);\r\n        Pawn blackPawn7 = new Pawn(7,7,false);\r\n        Pawn blackPawn8 = new Pawn(8,7,false);\r\n        Rook whiteRook1 = new Rook(1,1,true);\r\n        Rook whiteRook2 = new Rook(8,1,true);\r\n        Rook blackRook1 = new Rook(1,8,false);\r\n        Rook blackRook2 = new Rook(8,8,false);\r\n        Knight whiteKnight1 = new Knight(2,1,true);\r\n        Knight whiteKnight2 = new Knight(7,1,true);\r\n        Knight blackKnight1 = new Knight(2,8,false);\r\n        Knight blackKnight2 = new Knight(7,8,false);\r\n        Bishop whiteBishop1 = new Bishop(3,1,true);\r\n        Bishop whiteBishop2 = new Bishop(6,1,true);\r\n        Bishop blackBishop1 = new Bishop(3,8,false);\r\n        Bishop blackBishop2 = new Bishop(6,8,false);\r\n        King whiteKing = new King(5,1,true);\r\n        King blackKing = new King(5,8,false);\r\n        Queen whiteQueen = new Queen(4,1,true);\r\n        Queen blackQueen = new Queen(4,8,false);\r\n        all[0][0]= whitePawn1;\r\n        all[0][1]= whitePawn2;\r\n        all[0][2]= whitePawn3;\r\n        all[0][3]= whitePawn4;\r\n        all[0][4]= whitePawn5;\r\n        all[0][5]= whitePawn6;\r\n        all[0][6]= whitePawn7;\r\n        all[0][7]= whitePawn8;\r\n        all[0][8]= whiteRook1;\r\n        all[0][9]= whiteRook2;\r\n        all[0][10]= whiteKnight1;\r\n        all[0][11]= whiteKnight2;\r\n        all[0][12]= whiteBishop1;\r\n        all[0][13]= whiteBishop2;\r\n        all[0][14]= whiteKing;\r\n        all[0][15]= whiteQueen;\r\n        all[1][0]= blackPawn1;\r\n        all[1][1]= blackPawn2;\r\n        all[1][2]= blackPawn3;\r\n        all[1][3]= blackPawn4;\r\n        all[1][4]= blackPawn5;\r\n        all[1][5]= blackPawn6;\r\n        all[1][6]= blackPawn7;\r\n        all[1][7]= blackPawn8;\r\n        all[1][8]= blackRook1;\r\n        all[1][9]= blackRook2;\r\n        all[1][10]= blackKnight1;\r\n        all[1][11]= blackKnight2;\r\n        all[1][12]= blackBishop1;\r\n        all[1][13]= blackBishop2;\r\n        all[1][14]= blackKing;\r\n        all[1][15]= blackQueen;\r\n        //whiteBishop1.move(3,3);\r\n        System.out.println(\"Ready\");\r\n//        while(!selected){\r\n//            if (!mousePressed && StdDraw.isMousePressed && !selected){\r\n//                System.out.println(\"test\");\r\n//                mousePressed = true;\r\n//                ChessGame.selectTile();\r\n//            }\r\n//        }\r\n        while (true){\r\n            if (StdDraw.isMousePressed() && !mousePressed){\r\n                mousePressed = true;\r\n                selectTile();\r\n            } else if (!StdDraw.isMousePressed() && mousePressed) {\r\n                mousePressed = false;\r\n            }\r\n            else if (mousePressed) {\r\n                // hold stuff\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    public static void selectTile(){\r\n        System.out.println(\"firing\");\r\n        StdDraw.setPenColor(Color.BLUE);\r\n        selectedTile[0] = (int) (StdDraw.mouseX() * 16) + 1;\r\n        selectedTile[1] = (int) (StdDraw.mouseY() * 16) + 1;\r\n        StdDraw.square(selectedTile[0], selectedTile[1], 1/16.0);\r\n        selected = true;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ChessGame.java b/src/ChessGame.java
--- a/src/ChessGame.java	(revision 83a2fd7782dbe671502e4d6371e64a700678c107)
+++ b/src/ChessGame.java	(date 1669234164158)
@@ -1,4 +1,3 @@
-import javax.swing.plaf.synth.SynthDesktopIconUI;
 import java.awt.*;
 
 public class ChessGame {
@@ -82,16 +81,7 @@
 //            }
 //        }
         while (true){
-            if (StdDraw.isMousePressed() && !mousePressed){
-                mousePressed = true;
-                selectTile();
-            } else if (!StdDraw.isMousePressed() && mousePressed) {
-                mousePressed = false;
-            }
-            else if (mousePressed) {
-                // hold stuff
-            }
-
+            selectTile();
         }
 
     }
Index: src/StdDraw.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/******************************************************************************\r\n *  Compilation:  javac StdDraw.java\r\n *  Execution:    java StdDraw\r\n *  Dependencies: none\r\n *\r\n *  Standard drawing library. This class provides a basic capability for\r\n *  creating drawings with your programs. It uses a simple graphics model that\r\n *  allows you to create drawings consisting of geometric shapes (e.g.,\r\n *  points, lines, circles, rectangles) in a window on your computer\r\n *  and to save the drawings to a file.\r\n *\r\n *  Todo\r\n *  ----\r\n *    -  Add support for gradient fill, etc.\r\n *    -  Fix setCanvasSize() so that it can be called only once.\r\n *    -  Should setCanvasSize() reset xScale(), yScale(), penRadius(),\r\n *       penColor(), and font()\r\n *    -  On some systems, drawing a line (or other shape) that extends way\r\n *       beyond canvas (e.g., to infinity) dimensions does not get drawn.\r\n *\r\n *  Remarks\r\n *  -------\r\n *    -  don't use AffineTransform for rescaling since it inverts\r\n *       images and strings\r\n *\r\n ******************************************************************************/\r\n\r\nimport java.awt.BasicStroke;\r\nimport java.awt.Color;\r\nimport java.awt.Component;\r\nimport java.awt.FileDialog;\r\nimport java.awt.Font;\r\nimport java.awt.FontMetrics;\r\nimport java.awt.Graphics;\r\nimport java.awt.Graphics2D;\r\nimport java.awt.Image;\r\nimport java.awt.MediaTracker;\r\nimport java.awt.RenderingHints;\r\n//import java.awt.Toolkit;\r\n\r\nimport java.awt.event.ActionEvent;\r\nimport java.awt.event.ActionListener;\r\nimport java.awt.event.MouseEvent;\r\nimport java.awt.event.MouseListener;\r\nimport java.awt.event.MouseMotionListener;\r\nimport java.awt.event.KeyEvent;\r\nimport java.awt.event.KeyListener;\r\n\r\nimport java.awt.geom.Arc2D;\r\nimport java.awt.geom.Ellipse2D;\r\nimport java.awt.geom.GeneralPath;\r\nimport java.awt.geom.Line2D;\r\nimport java.awt.geom.Rectangle2D;\r\n\r\nimport java.awt.image.BufferedImage;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\n\r\nimport java.net.MalformedURLException;\r\nimport java.net.URL;\r\n\r\nimport java.util.LinkedList;\r\nimport java.util.TreeSet;\r\nimport java.util.NoSuchElementException;\r\nimport javax.imageio.ImageIO;\r\n\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JLabel;\r\n//import javax.swing.JMenu;\r\n// import javax.swing.JMenuBar;\r\n// import javax.swing.JMenuItem;\r\n// import javax.swing.KeyStroke;\r\n\r\n/**\r\n *  <p><b>Overview.</b>\r\n *  The {@code StdDraw} class provides a basic capability for\r\n *  creating drawings with your programs. It uses a simple graphics model that\r\n *  allows you to create drawings consisting of points, lines, squares,\r\n *  circles, and other geometric shapes in a window on your computer and\r\n *  to save the drawings to a file. Standard drawing also includes\r\n *  facilities for text, color, pictures, and animation, along with\r\n *  user interaction via the keyboard and mouse.\r\n *  <p>\r\n *  <b>Getting started.</b>\r\n *  To use this class, you must have {@code StdDraw.class} in your\r\n *  Java classpath. If you used our autoinstaller, you should be all set.\r\n *  Otherwise, either download\r\n *  <a href = \"https://introcs.cs.princeton.edu/java/code/stdlib.jar\">stdlib.jar</a>\r\n *  and add to your Java classpath or download\r\n *  <a href = \"https://introcs.cs.princeton.edu/java/stdlib/StdDraw.java\">StdDraw.java</a>\r\n *  and put a copy in your working directory.\r\n *  <p>\r\n *  Now, cut-and-paste the following short program into your editor:\r\n *  <pre>\r\n *   public class TestStdDraw {\r\n *       public static void main(String[] args) {\r\n *           StdDraw.setPenRadius(0.05);\r\n *           StdDraw.setPenColor(StdDraw.BLUE);\r\n *           StdDraw.point(0.5, 0.5);\r\n *           StdDraw.setPenColor(StdDraw.MAGENTA);\r\n *           StdDraw.line(0.2, 0.2, 0.8, 0.2);\r\n *       }\r\n *   }\r\n *  </pre>\r\n *  If you compile and execute the program, you should see a window\r\n *  appear with a thick magenta line and a blue point.\r\n *  This program illustrates the two main types of methods in standard\r\n *  drawing--methods that draw geometric shapes and methods that\r\n *  control drawing parameters.\r\n *  The methods {@code StdDraw.line()} and {@code StdDraw.point()}\r\n *  draw lines and points; the methods {@code StdDraw.setPenRadius()}\r\n *  and {@code StdDraw.setPenColor()} control the line thickness and color.\r\n *  <p>\r\n *  <b>Points and lines.</b>\r\n *  You can draw points and line segments with the following methods:\r\n *  <ul>\r\n *  <li> {@link #point(double x, double y)}\r\n *  <li> {@link #line(double x1, double y1, double x2, double y2)}\r\n *  </ul>\r\n *  <p>\r\n *  The <em>x</em>- and <em>y</em>-coordinates must be in the drawing area\r\n *  (between 0 and 1 and by default) or the points and lines will not be visible.\r\n *  <p>\r\n *  <b>Squares, circles, rectangles, and ellipses.</b>\r\n *  You can draw squares, circles, rectangles, and ellipses using\r\n *  the following methods:\r\n *  <ul>\r\n *  <li> {@link #circle(double x, double y, double radius)}\r\n *  <li> {@link #ellipse(double x, double y, double semiMajorAxis, double semiMinorAxis)}\r\n *  <li> {@link #square(double x, double y, double halfLength)}\r\n *  <li> {@link #rectangle(double x, double y, double halfWidth, double halfHeight)}\r\n *  </ul>\r\n *  <p>\r\n *  All of these methods take as arguments the location and size of the shape.\r\n *  The location is always specified by the <em>x</em>- and <em>y</em>-coordinates\r\n *  of its <em>center</em>.\r\n *  The size of a circle is specified by its radius and the size of an ellipse is\r\n *  specified by the lengths of its semi-major and semi-minor axes.\r\n *  The size of a square or rectangle is specified by its half-width or half-height.\r\n *  The convention for drawing squares and rectangles is parallel to those for\r\n *  drawing circles and ellipses, but may be unexpected to the uninitiated.\r\n *  <p>\r\n *  The methods above trace outlines of the given shapes. The following methods\r\n *  draw filled versions:\r\n *  <ul>\r\n *  <li> {@link #filledCircle(double x, double y, double radius)}\r\n *  <li> {@link #filledEllipse(double x, double y, double semiMajorAxis, double semiMinorAxis)}\r\n *  <li> {@link #filledSquare(double x, double y, double radius)}\r\n *  <li> {@link #filledRectangle(double x, double y, double halfWidth, double halfHeight)}\r\n *  </ul>\r\n *  <p>\r\n *  <b>Circular arcs.</b>\r\n *  You can draw circular arcs with the following method:\r\n *  <ul>\r\n *  <li> {@link #arc(double x, double y, double radius, double angle1, double angle2)}\r\n *  </ul>\r\n *  <p>\r\n *  The arc is from the circle centered at (<em>x</em>, <em>y</em>) of the specified radius.\r\n *  The arc extends from angle1 to angle2. By convention, the angles are\r\n *  <em>polar</em> (counterclockwise angle from the <em>x</em>-axis)\r\n *  and represented in degrees. For example, {@code StdDraw.arc(0.0, 0.0, 1.0, 0, 90)}\r\n *  draws the arc of the unit circle from 3 o'clock (0 degrees) to 12 o'clock (90 degrees).\r\n *  <p>\r\n *  <b>Polygons.</b>\r\n *  You can draw polygons with the following methods:\r\n *  <ul>\r\n *  <li> {@link #polygon(double[] x, double[] y)}\r\n *  <li> {@link #filledPolygon(double[] x, double[] y)}\r\n *  </ul>\r\n *  <p>\r\n *  The points in the polygon are ({@code x[i]}, {@code y[i]}).\r\n *  For example, the following code fragment draws a filled diamond\r\n *  with vertices (0.1, 0.2), (0.2, 0.3), (0.3, 0.2), and (0.2, 0.1):\r\n *  <pre>\r\n *   double[] x = { 0.1, 0.2, 0.3, 0.2 };\r\n *   double[] y = { 0.2, 0.3, 0.2, 0.1 };\r\n *   StdDraw.filledPolygon(x, y);\r\n *  </pre>\r\n *  <p>\r\n *  <b>Pen size.</b>\r\n *  The pen is circular, so that when you set the pen radius to <em>r</em>\r\n *  and draw a point, you get a circle of radius <em>r</em>. Also, lines are\r\n *  of thickness 2<em>r</em> and have rounded ends. The default pen radius\r\n *  is 0.005 and is not affected by coordinate scaling. This default pen\r\n *  radius is about 1/200 the width of the default canvas, so that if\r\n *  you draw 100 points equally spaced along a horizontal or vertical line,\r\n *  you will be able to see individual circles, but if you draw 200 such\r\n *  points, the result will look like a line.\r\n *  <ul>\r\n *  <li> {@link #setPenRadius(double radius)}\r\n *  </ul>\r\n *  <p>\r\n *  For example, {@code StdDraw.setPenRadius(0.025)} makes\r\n *  the thickness of the lines and the size of the points to be five times\r\n *  the 0.005 default.\r\n *  To draw points with the minimum possible radius (one pixel on typical\r\n *  displays), set the pen radius to 0.0.\r\n *  <p>\r\n *  <b>Pen color.</b>\r\n *  All geometric shapes (such as points, lines, and circles) are drawn using\r\n *  the current pen color. By default, it is black.\r\n *  You can change the pen color with the following methods:\r\n *  <ul>\r\n *  <li> {@link #setPenColor(int red, int green, int blue)}\r\n *  <li> {@link #setPenColor(Color color)}\r\n *  </ul>\r\n *  <p>\r\n *  The first method allows you to specify colors using the RGB color system.\r\n *  This <a href = \"http://johndyer.name/lab/colorpicker/\">color picker</a>\r\n *  is a convenient way to find a desired color.\r\n *  <p>\r\n *  The second method allows you to specify colors using the\r\n *  {@link Color} data type, which is defined in Java's {@link java.awt} pacakge.\r\n *  A number of colors are predefined in standard drawing:\r\n *  {@link #BLACK}, {@link #BLUE}, {@link #CYAN}, {@link #DARK_GRAY}, {@link #GRAY},\r\n *  {@link #GREEN}, {@link #LIGHT_GRAY}, {@link #MAGENTA}, {@link #ORANGE},\r\n *  {@link #PINK}, {@link #RED}, {@link #WHITE}, {@link #YELLOW},\r\n *  {@link #BOOK_BLUE}, {@link #BOOK_LIGHT_BLUE}, {@link #BOOK_RED}, and\r\n *  {@link #PRINCETON_ORANGE}.\r\n *  For example, {@code StdDraw.setPenColor(StdDraw.MAGENTA)} sets the\r\n *  pen color to magenta.\r\n *  <p>\r\n *  <b>Window title.</b>\r\n *  By default, the stanard drawing window title is \"Standard Draw\".\r\n *  You can change the title with the following method:\r\n *  <ul>\r\n *  <li> {@link #setTitle(String title)}\r\n *  </ul>\r\n *  <p>\r\n *  This sets the standard drawing window title to the specified string.\r\n *  <p>\r\n *  <b>Canvas size.</b>\r\n *  By default, all drawing takes places in a 512-by-512 canvas.\r\n *  The canvas does not include the window title or window border.\r\n *  You can change the size of the canvas with the following method:\r\n *  <ul>\r\n *  <li> {@link #setCanvasSize(int width, int height)}\r\n *  </ul>\r\n *  <p>\r\n *  This sets the canvas size to be <em>width</em>-by-<em>height</em> pixels.\r\n *  It also erases the current drawing and resets the coordinate system,\r\n *  pen radius, pen color, and font back to their default values.\r\n *  Ordinarly, this method is called only once, at the very beginning of a program.\r\n *  For example, {@code StdDraw.setCanvasSize(800, 800)}\r\n *  sets the canvas size to be 800-by-800 pixels.\r\n *  <p>\r\n *  <b>Canvas scale and coordinate system.</b>\r\n *  By default, all drawing takes places in the unit square, with (0, 0) at\r\n *  lower left and (1, 1) at upper right. You can change the default\r\n *  coordinate system with the following methods:\r\n *  <ul>\r\n *  <li> {@link #setXscale(double xmin, double xmax)}\r\n *  <li> {@link #setYscale(double ymin, double ymax)}\r\n *  <li> {@link #setScale(double min, double max)}\r\n *  </ul>\r\n *  <p>\r\n *  The arguments are the coordinates of the minimum and maximum\r\n *  <em>x</em>- or <em>y</em>-coordinates that will appear in the canvas.\r\n *  For example, if you  wish to use the default coordinate system but\r\n *  leave a small margin, you can call {@code StdDraw.setScale(-.05, 1.05)}.\r\n *  <p>\r\n *  These methods change the coordinate system for subsequent drawing\r\n *  commands; they do not affect previous drawings.\r\n *  These methods do not change the canvas size; so, if the <em>x</em>-\r\n *  and <em>y</em>-scales are different, squares will become rectangles\r\n *  and circles will become ellipses.\r\n *  <p>\r\n *  <b>Text.</b>\r\n *  You can use the following methods to annotate your drawings with text:\r\n *  <ul>\r\n *  <li> {@link #text(double x, double y, String text)}\r\n *  <li> {@link #text(double x, double y, String text, double degrees)}\r\n *  <li> {@link #textLeft(double x, double y, String text)}\r\n *  <li> {@link #textRight(double x, double y, String text)}\r\n *  </ul>\r\n *  <p>\r\n *  The first two methods write the specified text in the current font,\r\n *  centered at (<em>x</em>, <em>y</em>).\r\n *  The second method allows you to rotate the text.\r\n *  The last two methods either left- or right-align the text at (<em>x</em>, <em>y</em>).\r\n *  <p>\r\n *  The default font is a Sans Serif font with point size 16.\r\n *  You can use the following method to change the font:\r\n *  <ul>\r\n *  <li> {@link #setFont(Font font)}\r\n *  </ul>\r\n *  <p>\r\n *  To specify the font, you use the {@link Font} data type,\r\n *  which is defined in Java's {@link java.awt} package.\r\n *  This allows you to\r\n *  choose the face, size, and style of the font. For example, the following\r\n *  code fragment sets the font to Arial Bold, 60 point.\r\n *  The <code>import</code> statement allows you to refer to <code>Font</code>\r\n *  directly, without needing the fully qualified name <code>java.awt.Font</code>.\r\n *  <pre>\r\n *   import java.awt.Font;\r\n *   ...\r\n *   Font font = new Font(\"Arial\", Font.BOLD, 60);\r\n *   StdDraw.setFont(font);\r\n *   StdDraw.text(0.5, 0.5, \"Hello, World\");\r\n *  </pre>\r\n *  <p>\r\n *  <b>Images.</b>\r\n *  You can use the following methods to add images to your drawings:\r\n *  <ul>\r\n *  <li> {@link #picture(double x, double y, String filename)}\r\n *  <li> {@link #picture(double x, double y, String filename, double degrees)}\r\n *  <li> {@link #picture(double x, double y, String filename, double scaledWidth, double scaledHeight)}\r\n *  <li> {@link #picture(double x, double y, String filename, double scaledWidth, double scaledHeight, double degrees)}\r\n *  </ul>\r\n *  <p>\r\n *  These methods draw the specified image, centered at (<em>x</em>, <em>y</em>).\r\n *  The image must be in a supported file format (typically JPEG, PNG, GIF TIFF, and BMP).\r\n *  The image will display at its native size, independent of the coordinate system.\r\n *  Optionally, you can rotate the image a specified number of degrees counterclockwise\r\n *  or rescale it to fit snugly inside a width-by-height bounding box.\r\n *  <p>\r\n *  <b>Saving to a file.</b>\r\n *  You can save your image to a file using the <em>File \\0x2192 Save</em> menu option.\r\n *  You can also save a file programatically using the following method:\r\n *  <ul>\r\n *  <li> {@link #save(String filename)}\r\n *  </ul>\r\n *  <p>\r\n *  You can save the drawing to a file in a supported file format\r\n *  (typically JPEG, PNG, GIF TIFF, and BMP).\r\n *  We recommend using PNG for drawing that consist solely of geometric shapes\r\n *  and JPEG for drawings that contains pictures.\r\n *  <p>\r\n *  <b>Clearing the canvas.</b>\r\n *  To clear the entire drawing canvas, you can use the following methods:\r\n *  <ul>\r\n *  <li> {@link #clear()}\r\n *  <li> {@link #clear(Color color)}\r\n *  </ul>\r\n *  <p>\r\n *  The first method clears the canvas to white; the second method\r\n *  allows you to specify a color of your choice. For example,\r\n *  {@code StdDraw.clear(StdDraw.LIGHT_GRAY)} clears the canvas to a shade\r\n *  of gray.\r\n *  <p>\r\n *  <b>Computer animations and double buffering.</b>\r\n *  Double buffering is one of the most powerful features of standard drawing,\r\n *  enabling computer animations.\r\n *  The following methods control the way in which objects are drawn:\r\n *  <ul>\r\n *  <li> {@link #enableDoubleBuffering()}\r\n *  <li> {@link #disableDoubleBuffering()}\r\n *  <li> {@link #show()}\r\n *  <li> {@link #pause(int t)}\r\n *  </ul>\r\n *  <p>\r\n *  By default, double buffering is disabled, which means that as soon as you\r\n *  call a drawing\r\n *  method--such as {@code point()} or {@code line()}--the\r\n *  results appear on the screen.\r\n *  <p>\r\n *  When double buffering is enabled by calling {@link #enableDoubleBuffering()},\r\n *  all drawing takes place on the <em>offscreen canvas</em>. The offscreen canvas\r\n *  is not displayed. Only when you call\r\n *  {@link #show()} does your drawing get copied from the offscreen canvas to\r\n *  the onscreen canvas, where it is displayed in the standard drawing window. You\r\n *  can think of double buffering as collecting all of the lines, points, shapes,\r\n *  and text that you tell it to draw, and then drawing them all\r\n *  <em>simultaneously</em>, upon request.\r\n *  <p>\r\n *  The most important use of double buffering is to produce computer\r\n *  animations, creating the illusion of motion by rapidly\r\n *  displaying static drawings. To produce an animation, repeat\r\n *  the following four steps:\r\n *  <ul>\r\n *  <li> Clear the offscreen canvas.\r\n *  <li> Draw objects on the offscreen canvas.\r\n *  <li> Copy the offscreen canvas to the onscreen canvas.\r\n *  <li> Wait for a short while.\r\n *  </ul>\r\n *  <p>\r\n *  The {@link #clear()}, {@link #show()}, and {@link #pause(int t)} methods\r\n *  support the first, third, and fourth of these steps, respectively.\r\n *  <p>\r\n *  For example, this code fragment animates two balls moving in a circle.\r\n *  <pre>\r\n *   StdDraw.setScale(-2, +2);\r\n *   StdDraw.enableDoubleBuffering();\r\n *\r\n *   for (double t = 0.0; true; t += 0.02) {\r\n *       double x = Math.sin(t);\r\n *       double y = Math.cos(t);\r\n *       StdDraw.clear();\r\n *       StdDraw.filledCircle(x, y, 0.05);\r\n *       StdDraw.filledCircle(-x, -y, 0.05);\r\n *       StdDraw.show();\r\n *       StdDraw.pause(20);\r\n *   }\r\n *  </pre>\r\n *  <p>\r\n *  <b>Keyboard and mouse inputs.</b>\r\n *  Standard drawing has very basic support for keyboard and mouse input.\r\n *  It is much less powerful than most user interface libraries provide, but also much simpler.\r\n *  You can use the following methods to intercept mouse events:\r\n *  <ul>\r\n *  <li> {@link #isMousePressed()}\r\n *  <li> {@link #mouseX()}\r\n *  <li> {@link #mouseY()}\r\n *  </ul>\r\n *  <p>\r\n *  The first method tells you whether a mouse button is currently being pressed.\r\n *  The last two methods tells you the <em>x</em>- and <em>y</em>-coordinates of the mouse's\r\n *  current position, using the same coordinate system as the canvas (the unit square, by default).\r\n *  You should use these methods in an animation loop that waits a short while before trying\r\n *  to poll the mouse for its current state.\r\n *  You can use the following methods to intercept keyboard events:\r\n *  <ul>\r\n *  <li> {@link #hasNextKeyTyped()}\r\n *  <li> {@link #nextKeyTyped()}\r\n *  <li> {@link #isKeyPressed(int keycode)}\r\n *  </ul>\r\n *  <p>\r\n *  If the user types lots of keys, they will be saved in a list until you process them.\r\n *  The first method tells you whether the user has typed a key (that your program has\r\n *  not yet processed).\r\n *  The second method returns the next key that the user typed (that your program has\r\n *  not yet processed) and removes it from the list of saved keystrokes.\r\n *  The third method tells you whether a key is currently being pressed.\r\n *  <p>\r\n *  <b>Accessing control parameters.</b>\r\n *  You can use the following methods to access the current pen color, pen radius,\r\n *  and font:\r\n *  <ul>\r\n *  <li> {@link #getPenColor()}\r\n *  <li> {@link #getPenRadius()}\r\n *  <li> {@link #getFont()}\r\n *  </ul>\r\n *  <p>\r\n *  These methods are useful when you want to temporarily change a\r\n *  control parameter and, later, reset it back to its original value.\r\n *  <p>\r\n *  <b>Corner cases.</b>\r\n *  Here are some corner cases.\r\n *  <ul>\r\n *  <li> Drawing an object outside (or partly outside) the canvas is permitted.\r\n *       However, only the part of the object that appears inside the canvas\r\n *       will be visible.\r\n *  <li> Due to floating-point issues, an object drawn with an <em>x</em>- or\r\n *       <em>y</em>-coordinate that is way outside the canvas (such as the line segment\r\n *       from (0.5, -10^308) to (0.5, 10^308) may not be visible even in the\r\n *       part of the canvas where it should be.\r\n *  <li> Any method that is passed a {@code null} argument will throw an\r\n *       {@link IllegalArgumentException}.\r\n *  <li> Any method that is passed a {@link Double#NaN},\r\n *       {@link Double#POSITIVE_INFINITY}, or {@link Double#NEGATIVE_INFINITY}\r\n *       argument will throw an {@link IllegalArgumentException}.\r\n *  </ul>\r\n *  <p>\r\n *  <b>Performance tricks.</b>\r\n *  Standard drawing is capable of drawing large amounts of data.\r\n *  Here are a few tricks and tips:\r\n *  <ul>\r\n *  <li> Use <em>double buffering</em> for static drawing with a large\r\n *       number of objects.\r\n *       That is, call {@link #enableDoubleBuffering()} before\r\n *       the sequence of drawing commands and call {@link #show()} afterwards.\r\n *       Incrementally displaying a complex drawing while it is being\r\n *       created can be intolerably inefficient on many computer systems.\r\n *  <li> When drawing computer animations, call {@code show()}\r\n *       only once per frame, not after drawing each individual object.\r\n *  <li> If you call {@code picture()} multiple times with the same filename,\r\n *       Java will cache the image, so you do not incur the cost of reading\r\n *       from a file each time.\r\n *  </ul>\r\n *  <p>\r\n *  <b>Known bugs and issues.</b>\r\n *  <ul>\r\n *  <li> The {@code picture()} methods may not draw the portion of the image that is\r\n *       inside the canvas if the center point (<em>x</em>, <em>y</em>) is outside the\r\n *       canvas.\r\n *       This bug appears only on some systems.\r\n *  </ul>\r\n *  <p>\r\n *  <b>Reference.</b>\r\n *  For additional documentation,\r\n *  see <a href=\"https://introcs.cs.princeton.edu/15inout\">Section 1.5</a> of\r\n *  <em>Computer Science: An Interdisciplinary Approach</em>\r\n *  by Robert Sedgewick and Kevin Wayne.\r\n *\r\n *  @author Robert Sedgewick\r\n *  @author Kevin Wayne\r\n */\r\npublic final class StdDraw implements ActionListener, MouseListener, MouseMotionListener, KeyListener {\r\n\r\n    /**\r\n     *  The color black.\r\n     */\r\n    public static final Color BLACK = Color.BLACK;\r\n\r\n    /**\r\n     *  The color blue.\r\n     */\r\n    public static final Color BLUE = Color.BLUE;\r\n\r\n    /**\r\n     *  The color cyan.\r\n     */\r\n    public static final Color CYAN = Color.CYAN;\r\n\r\n    /**\r\n     *  The color dark gray.\r\n     */\r\n    public static final Color DARK_GRAY = Color.DARK_GRAY;\r\n\r\n    /**\r\n     *  The color gray.\r\n     */\r\n    public static final Color GRAY = Color.GRAY;\r\n\r\n    /**\r\n     *  The color green.\r\n     */\r\n    public static final Color GREEN  = Color.GREEN;\r\n\r\n    /**\r\n     *  The color light gray.\r\n     */\r\n    public static final Color LIGHT_GRAY = Color.LIGHT_GRAY;\r\n\r\n    /**\r\n     *  The color magenta.\r\n     */\r\n    public static final Color MAGENTA = Color.MAGENTA;\r\n\r\n    /**\r\n     *  The color orange.\r\n     */\r\n    public static final Color ORANGE = Color.ORANGE;\r\n\r\n    /**\r\n     *  The color pink.\r\n     */\r\n    public static final Color PINK = Color.PINK;\r\n\r\n    /**\r\n     *  The color red.\r\n     */\r\n    public static final Color RED = Color.RED;\r\n\r\n    /**\r\n     *  The color white.\r\n     */\r\n    public static final Color WHITE = Color.WHITE;\r\n\r\n    /**\r\n     *  The color yellow.\r\n     */\r\n    public static final Color YELLOW = Color.YELLOW;\r\n\r\n    /**\r\n     * Shade of blue used in <em>Introduction to Programming in Java</em>.\r\n     * It is Pantone 300U. The RGB values are approximately (9, 90, 166).\r\n     */\r\n    public static final Color BOOK_BLUE = new Color(9, 90, 166);\r\n\r\n    /**\r\n     * Shade of light blue used in <em>Introduction to Programming in Java</em>.\r\n     * The RGB values are approximately (103, 198, 243).\r\n     */\r\n    public static final Color BOOK_LIGHT_BLUE = new Color(103, 198, 243);\r\n\r\n    /**\r\n     * Shade of red used in <em>Algorithms, 4th edition</em>.\r\n     * It is Pantone 1805U. The RGB values are approximately (150, 35, 31).\r\n     */\r\n    public static final Color BOOK_RED = new Color(150, 35, 31);\r\n\r\n    /**\r\n     * Shade of orange used in Princeton University's identity.\r\n     * It is PMS 158. The RGB values are approximately (245, 128, 37).\r\n     */\r\n    public static final Color PRINCETON_ORANGE = new Color(245, 128, 37);\r\n\r\n    // default colors\r\n    private static final Color DEFAULT_PEN_COLOR   = BLACK;\r\n    private static final Color DEFAULT_CLEAR_COLOR = WHITE;\r\n\r\n    // current pen color\r\n    private static Color penColor;\r\n\r\n    // default title of standard drawing window\r\n    private static final String DEFAULT_WINDOW_TITLE = \"Standard Draw\";\r\n\r\n    // current title of standard drawing window\r\n    private static String windowTitle = DEFAULT_WINDOW_TITLE;\r\n\r\n    // default canvas size is DEFAULT_SIZE-by-DEFAULT_SIZE\r\n    private static final int DEFAULT_SIZE = 512;\r\n    private static int width  = DEFAULT_SIZE;\r\n    private static int height = DEFAULT_SIZE;\r\n\r\n    // default pen radius\r\n    private static final double DEFAULT_PEN_RADIUS = 0.002;\r\n\r\n    // current pen radius\r\n    private static double penRadius;\r\n\r\n    // show we draw immediately or wait until next show?\r\n    private static boolean defer = false;\r\n\r\n    // boundary of drawing canvas, 0% border\r\n    // private static final double BORDER = 0.05;\r\n    private static final double BORDER = 0.00;\r\n    private static final double DEFAULT_XMIN = 0.0;\r\n    private static final double DEFAULT_XMAX = 1.0;\r\n    private static final double DEFAULT_YMIN = 0.0;\r\n    private static final double DEFAULT_YMAX = 1.0;\r\n    private static double xmin, ymin, xmax, ymax;\r\n\r\n    // for synchronization\r\n    private static Object mouseLock = new Object();\r\n    private static Object keyLock = new Object();\r\n\r\n    // default font\r\n    private static final Font DEFAULT_FONT = new Font(\"SansSerif\", Font.PLAIN, 16);\r\n\r\n    // current font\r\n    private static Font font;\r\n\r\n    // double buffered graphics\r\n    private static BufferedImage offscreenImage, onscreenImage;\r\n    private static Graphics2D offscreen, onscreen;\r\n\r\n    // singleton for callbacks: avoids generation of extra .class files\r\n    private static StdDraw std = new StdDraw();\r\n\r\n    // the frame for drawing to the screen\r\n    private static JFrame frame;\r\n\r\n    // mouse state\r\n    private static boolean isMousePressed = false;\r\n    private static double mouseX = 0;\r\n    private static double mouseY = 0;\r\n\r\n    // queue of typed key characters\r\n    private static LinkedList<Character> keysTyped;\r\n\r\n    // set of key codes currently pressed down\r\n    private static TreeSet<Integer> keysDown;\r\n\r\n    // singleton pattern: client can't instantiate\r\n    private StdDraw() { }\r\n\r\n\r\n    // static initializer\r\n    static {\r\n        init();\r\n    }\r\n\r\n    /**\r\n     * Sets the canvas (drawing area) to be 512-by-512 pixels.\r\n     * This also erases the current drawing and resets the coordinate system,\r\n     * pen radius, pen color, and font back to their default values.\r\n     * Ordinarly, this method is called once, at the very beginning\r\n     * of a program.\r\n     */\r\n    public static void setCanvasSize() {\r\n        setCanvasSize(DEFAULT_SIZE, DEFAULT_SIZE);\r\n    }\r\n\r\n    /**\r\n     * Sets the canvas (drawing area) to be <em>width</em>-by-<em>height</em> pixels.\r\n     * This also erases the current drawing and resets the coordinate system,\r\n     * pen radius, pen color, and font back to their default values.\r\n     * Ordinarly, this method is called once, at the very beginning\r\n     * of a program.\r\n     *\r\n     * @param  canvasWidth the width as a number of pixels\r\n     * @param  canvasHeight the height as a number of pixels\r\n     * @throws IllegalArgumentException unless both {@code canvasWidth} and\r\n     *         {@code canvasHeight} are positive\r\n     */\r\n    public static void setCanvasSize(int canvasWidth, int canvasHeight) {\r\n        if (canvasWidth <= 0) throw new IllegalArgumentException(\"width must be positive\");\r\n        if (canvasHeight <= 0) throw new IllegalArgumentException(\"height must be positive\");\r\n        width = canvasWidth;\r\n        height = canvasHeight;\r\n        init();\r\n    }\r\n\r\n    // init\r\n    private static void init() {\r\n        if (frame != null) frame.setVisible(false);\r\n        frame = new JFrame();\r\n        offscreenImage = new BufferedImage(2*width, 2*height, BufferedImage.TYPE_INT_ARGB);\r\n        onscreenImage  = new BufferedImage(2*width, 2*height, BufferedImage.TYPE_INT_ARGB);\r\n        offscreen = offscreenImage.createGraphics();\r\n        onscreen  = onscreenImage.createGraphics();\r\n        offscreen.scale(2.0, 2.0);  // since we made it 2x as big\r\n\r\n        setXscale();\r\n        setYscale();\r\n        offscreen.setColor(DEFAULT_CLEAR_COLOR);\r\n        offscreen.fillRect(0, 0, width, height);\r\n        setPenColor();\r\n        setPenRadius();\r\n        setFont();\r\n        clear();\r\n\r\n        // initialize keystroke buffers\r\n        keysTyped = new LinkedList<Character>();\r\n        keysDown = new TreeSet<Integer>();\r\n\r\n        // add antialiasing\r\n        RenderingHints hints = new RenderingHints(RenderingHints.KEY_ANTIALIASING,\r\n                                                  RenderingHints.VALUE_ANTIALIAS_ON);\r\n        hints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\r\n        offscreen.addRenderingHints(hints);\r\n\r\n        // frame stuff\r\n        RetinaImageIcon icon = new RetinaImageIcon(onscreenImage);\r\n        JLabel draw = new JLabel(icon);\r\n\r\n        draw.addMouseListener(std);\r\n        draw.addMouseMotionListener(std);\r\n\r\n        frame.setContentPane(draw);\r\n        frame.addKeyListener(std);    // JLabel cannot get keyboard focus\r\n        frame.setFocusTraversalKeysEnabled(false);  // allow VK_TAB with isKeyPressed()\r\n        frame.setResizable(false);\r\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);            // closes all windows\r\n        // frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);      // closes only current window\r\n        frame.setTitle(windowTitle);\r\n        //frame.setJMenuBar(createMenuBar());\r\n        frame.pack();\r\n        frame.requestFocusInWindow();\r\n        frame.setVisible(true);\r\n    }\r\n\r\n    // create the menu bar (changed to private)\r\n    /**\r\n     * @return\r\n     */\r\n    // private static JMenuBar createMenuBar() {\r\n    //     JMenuBar menuBar = new JMenuBar();\r\n    //     JMenu menu = new JMenu(\"File\");\r\n    //     menuBar.add(menu);\r\n    //     JMenuItem menuItem1 = new JMenuItem(\" Save...   \");\r\n    //     menuItem1.addActionListener(std);\r\n    //     // Java 10+: replace getMenuShortcutKeyMask() with getMenuShortcutKeyMaskEx()\r\n    //     menuItem1.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,\r\n    //                             Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));\r\n    //     menu.add(menuItem1);\r\n    //     return menuBar;\r\n    //}\r\n\r\n   /***************************************************************************\r\n    *  Input validation helper methods.\r\n    ***************************************************************************/\r\n\r\n    // throw an IllegalArgumentException if x is NaN or infinite\r\n    private static void validate(double x, String name) {\r\n        if (Double.isNaN(x)) throw new IllegalArgumentException(name + \" is NaN\");\r\n        if (Double.isInfinite(x)) throw new IllegalArgumentException(name + \" is infinite\");\r\n    }\r\n\r\n    // throw an IllegalArgumentException if s is null\r\n    private static void validateNonnegative(double x, String name) {\r\n        if (x < 0) throw new IllegalArgumentException(name + \" negative\");\r\n    }\r\n\r\n    // throw an IllegalArgumentException if s is null\r\n    private static void validateNotNull(Object x, String name) {\r\n        if (x == null) throw new IllegalArgumentException(name + \" is null\");\r\n    }\r\n\r\n\r\n   /***************************************************************************\r\n    *  Set the title of standard drawing window.\r\n    ***************************************************************************/\r\n\r\n    /**\r\n     * Sets the title of the standard drawing window to the specified string.\r\n     *\r\n     * @param  title the title\r\n     * @throws IllegalArgumentException if {@code title} is {@code null}\r\n     */\r\n    public static void setTitle(String title) {\r\n        validateNotNull(title, \"title\");\r\n        frame.setTitle(title);\r\n        windowTitle = title;\r\n    }\r\n\r\n   /***************************************************************************\r\n    *  User and screen coordinate systems.\r\n    ***************************************************************************/\r\n\r\n    /**\r\n     * Sets the <em>x</em>-scale to be the default (between 0.0 and 1.0).\r\n     */\r\n    public static void setXscale() {\r\n        setXscale(DEFAULT_XMIN, DEFAULT_XMAX);\r\n    }\r\n\r\n    public static Color randomColor(int alpha){\r\n        int r = (int) (Math.random() * 256);\r\n        int g = (int) (Math.random() * 256);\r\n        int b = (int) (Math.random() * 256);\r\n        return new Color(r, g, b, alpha);\r\n    }\r\n    public static Color randomColor(){\r\n        int r = (int) (Math.random() * 256);\r\n        int g = (int) (Math.random() * 256);\r\n        int b = (int) (Math.random() * 256);\r\n        return new Color(r, g, b);\r\n    }\r\n\r\n    /**\r\n     * Sets the <em>y</em>-scale to be the default (between 0.0 and 1.0).\r\n     */\r\n    public static void setYscale() {\r\n        setYscale(DEFAULT_YMIN, DEFAULT_YMAX);\r\n    }\r\n\r\n    /**\r\n     * Sets the <em>x</em>-scale and <em>y</em>-scale to be the default\r\n     * (between 0.0 and 1.0).\r\n     */\r\n    public static void setScale() {\r\n        setXscale();\r\n        setYscale();\r\n    }\r\n\r\n    /**\r\n     * Sets the <em>x</em>-scale to the specified range.\r\n     *\r\n     * @param  min the minimum value of the <em>x</em>-scale\r\n     * @param  max the maximum value of the <em>x</em>-scale\r\n     * @throws IllegalArgumentException if {@code (max == min)}\r\n     * @throws IllegalArgumentException if either {@code min} or {@code max} is either NaN or infinite\r\n     */\r\n    public static void setXscale(double min, double max) {\r\n        validate(min, \"min\");\r\n        validate(max, \"max\");\r\n        double size = max - min;\r\n        if (size == 0.0) throw new IllegalArgumentException(\"the min and max are the same\");\r\n        synchronized (mouseLock) {\r\n            xmin = min - BORDER * size;\r\n            xmax = max + BORDER * size;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the <em>y</em>-scale to the specified range.\r\n     *\r\n     * @param  min the minimum value of the <em>y</em>-scale\r\n     * @param  max the maximum value of the <em>y</em>-scale\r\n     * @throws IllegalArgumentException if {@code (max == min)}\r\n     * @throws IllegalArgumentException if either {@code min} or {@code max} is either NaN or infinite\r\n     */\r\n    public static void setYscale(double min, double max) {\r\n        validate(min, \"min\");\r\n        validate(max, \"max\");\r\n        double size = max - min;\r\n        if (size == 0.0) throw new IllegalArgumentException(\"the min and max are the same\");\r\n        synchronized (mouseLock) {\r\n            ymin = min - BORDER * size;\r\n            ymax = max + BORDER * size;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets both the <em>x</em>-scale and <em>y</em>-scale to the (same) specified range.\r\n     *\r\n     * @param  min the minimum value of the <em>x</em>- and <em>y</em>-scales\r\n     * @param  max the maximum value of the <em>x</em>- and <em>y</em>-scales\r\n     * @throws IllegalArgumentException if {@code (max == min)}\r\n     * @throws IllegalArgumentException if either {@code min} or {@code max} is either NaN or infinite\r\n     */\r\n    public static void setScale(double min, double max) {\r\n        validate(min, \"min\");\r\n        validate(max, \"max\");\r\n        double size = max - min;\r\n        if (size == 0.0) throw new IllegalArgumentException(\"the min and max are the same\");\r\n        synchronized (mouseLock) {\r\n            xmin = min - BORDER * size;\r\n            xmax = max + BORDER * size;\r\n            ymin = min - BORDER * size;\r\n            ymax = max + BORDER * size;\r\n        }\r\n    }\r\n\r\n    // helper functions that scale from user coordinates to screen coordinates and back\r\n    private static double  scaleX(double x) { return width  * (x - xmin) / (xmax - xmin); }\r\n    private static double  scaleY(double y) { return height * (ymax - y) / (ymax - ymin); }\r\n    private static double factorX(double w) { return w * width  / Math.abs(xmax - xmin);  }\r\n    private static double factorY(double h) { return h * height / Math.abs(ymax - ymin);  }\r\n    private static double   userX(double x) { return xmin + x * (xmax - xmin) / width;    }\r\n    private static double   userY(double y) { return ymax - y * (ymax - ymin) / height;   }\r\n\r\n\r\n    /**\r\n     * Clears the screen to the default color (white).\r\n     */\r\n    public static void clear() {\r\n        clear(DEFAULT_CLEAR_COLOR);\r\n    }\r\n\r\n    /**\r\n     * Clears the screen to the specified color.\r\n     *\r\n     * @param color the color to make the background\r\n     * @throws IllegalArgumentException if {@code color} is {@code null}\r\n     */\r\n    public static void clear(Color color) {\r\n        validateNotNull(color, \"color\");\r\n        offscreen.setColor(color);\r\n        offscreen.fillRect(0, 0, width, height);\r\n        offscreen.setColor(penColor);\r\n        draw();\r\n    }\r\n\r\n    /**\r\n     * Returns the current pen radius.\r\n     *\r\n     * @return the current value of the pen radius\r\n     */\r\n    public static double getPenRadius() {\r\n        return penRadius;\r\n    }\r\n\r\n    /**\r\n     * Sets the pen size to the default size (0.002).\r\n     * The pen is circular, so that lines have rounded ends, and when you set the\r\n     * pen radius and draw a point, you get a circle of the specified radius.\r\n     * The pen radius is not affected by coordinate scaling.\r\n     */\r\n    public static void setPenRadius() {\r\n        setPenRadius(DEFAULT_PEN_RADIUS);\r\n    }\r\n\r\n    /**\r\n     * Sets the radius of the pen to the specified size.\r\n     * The pen is circular, so that lines have rounded ends, and when you set the\r\n     * pen radius and draw a point, you get a circle of the specified radius.\r\n     * The pen radius is not affected by coordinate scaling.\r\n     *\r\n     * @param  radius the radius of the pen\r\n     * @throws IllegalArgumentException if {@code radius} is negative, NaN, or infinite\r\n     */\r\n    public static void setPenRadius(double radius) {\r\n        validate(radius, \"pen radius\");\r\n        validateNonnegative(radius, \"pen radius\");\r\n\r\n        penRadius = radius;\r\n        float scaledPenRadius = (float) (radius * DEFAULT_SIZE);\r\n        BasicStroke stroke = new BasicStroke(scaledPenRadius, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND);\r\n        // BasicStroke stroke = new BasicStroke(scaledPenRadius);\r\n        offscreen.setStroke(stroke);\r\n    }\r\n\r\n    /**\r\n     * Returns the current pen color.\r\n     *\r\n     * @return the current pen color\r\n     */\r\n    public static Color getPenColor() {\r\n        return penColor;\r\n    }\r\n\r\n    /**\r\n     * Sets the pen color to the default color (black).\r\n     */\r\n    public static void setPenColor() {\r\n        setPenColor(DEFAULT_PEN_COLOR);\r\n    }\r\n\r\n    /**\r\n     * Sets the pen color to the specified color.\r\n     * <p>\r\n     * The predefined pen colors are\r\n     * {@code StdDraw.BLACK}, {@code StdDraw.BLUE}, {@code StdDraw.CYAN},\r\n     * {@code StdDraw.DARK_GRAY}, {@code StdDraw.GRAY}, {@code StdDraw.GREEN},\r\n     * {@code StdDraw.LIGHT_GRAY}, {@code StdDraw.MAGENTA}, {@code StdDraw.ORANGE},\r\n     * {@code StdDraw.PINK}, {@code StdDraw.RED}, {@code StdDraw.WHITE}, and\r\n     * {@code StdDraw.YELLOW}.\r\n     *\r\n     * @param color the color to make the pen\r\n     * @throws IllegalArgumentException if {@code color} is {@code null}\r\n     */\r\n    public static void setPenColor(Color color) {\r\n        validateNotNull(color, \"color\");\r\n        penColor = color;\r\n        offscreen.setColor(penColor);\r\n    }\r\n\r\n    /**\r\n     * Sets the pen color to the specified RGB color.\r\n     *\r\n     * @param  red the amount of red (between 0 and 255)\r\n     * @param  green the amount of green (between 0 and 255)\r\n     * @param  blue the amount of blue (between 0 and 255)\r\n     * @throws IllegalArgumentException if {@code red}, {@code green},\r\n     *         or {@code blue} is outside its prescribed range\r\n     */\r\n    public static void setPenColor(int red, int green, int blue) {\r\n        if (red   < 0 || red   >= 256) throw new IllegalArgumentException(\"red must be between 0 and 255\");\r\n        if (green < 0 || green >= 256) throw new IllegalArgumentException(\"green must be between 0 and 255\");\r\n        if (blue  < 0 || blue  >= 256) throw new IllegalArgumentException(\"blue must be between 0 and 255\");\r\n        setPenColor(new Color(red, green, blue));\r\n    }\r\n\r\n    /**\r\n     * Returns the current font.\r\n     *\r\n     * @return the current font\r\n     */\r\n    public static Font getFont() {\r\n        return font;\r\n    }\r\n\r\n    /**\r\n     * Sets the font to the default font (sans serif, 16 point).\r\n     */\r\n    public static void setFont() {\r\n        setFont(DEFAULT_FONT);\r\n    }\r\n\r\n    /**\r\n     * Sets the font to the specified value.\r\n     *\r\n     * @param font the font\r\n     * @throws IllegalArgumentException if {@code font} is {@code null}\r\n     */\r\n    public static void setFont(Font font) {\r\n        validateNotNull(font, \"font\");\r\n        StdDraw.font = font;\r\n    }\r\n\r\n\r\n   /***************************************************************************\r\n    *  Drawing geometric shapes.\r\n    ***************************************************************************/\r\n\r\n    /**\r\n     * Draws a line segment between (<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>) and\r\n     * (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>).\r\n     *\r\n     * @param  x0 the <em>x</em>-coordinate of one endpoint\r\n     * @param  y0 the <em>y</em>-coordinate of one endpoint\r\n     * @param  x1 the <em>x</em>-coordinate of the other endpoint\r\n     * @param  y1 the <em>y</em>-coordinate of the other endpoint\r\n     * @throws IllegalArgumentException if any coordinate is either NaN or infinite\r\n     */\r\n    public static void line(double x0, double y0, double x1, double y1) {\r\n        validate(x0, \"x0\");\r\n        validate(y0, \"y0\");\r\n        validate(x1, \"x1\");\r\n        validate(y1, \"y1\");\r\n        offscreen.draw(new Line2D.Double(scaleX(x0), scaleY(y0), scaleX(x1), scaleY(y1)));\r\n        draw();\r\n    }\r\n\r\n    /**\r\n     * Draws one pixel at (<em>x</em>, <em>y</em>).\r\n     * This method is private because pixels depend on the display.\r\n     * To achieve the same effect, set the pen radius to 0 and call {@code point()}.\r\n     *\r\n     * @param  x the <em>x</em>-coordinate of the pixel\r\n     * @param  y the <em>y</em>-coordinate of the pixel\r\n     * @throws IllegalArgumentException if {@code x} or {@code y} is either NaN or infinite\r\n     */\r\n    private static void pixel(double x, double y) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n        offscreen.fillRect((int) Math.round(scaleX(x)), (int) Math.round(scaleY(y)), 1, 1);\r\n    }\r\n\r\n    /**\r\n     * Draws a point centered at (<em>x</em>, <em>y</em>).\r\n     * The point is a filled circle whose radius is equal to the pen radius.\r\n     * To draw a single-pixel point, first set the pen radius to 0.\r\n     *\r\n     * @param x the <em>x</em>-coordinate of the point\r\n     * @param y the <em>y</em>-coordinate of the point\r\n     * @throws IllegalArgumentException if either {@code x} or {@code y} is either NaN or infinite\r\n     */\r\n    public static void point(double x, double y) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n\r\n        double xs = scaleX(x);\r\n        double ys = scaleY(y);\r\n        double r = penRadius;\r\n        float scaledPenRadius = (float) (r * DEFAULT_SIZE);\r\n\r\n        // double ws = factorX(2*r);\r\n        // double hs = factorY(2*r);\r\n        // if (ws <= 1 && hs <= 1) pixel(x, y);\r\n        if (scaledPenRadius <= 1) pixel(x, y);\r\n        else offscreen.fill(new Ellipse2D.Double(xs - scaledPenRadius/2, ys - scaledPenRadius/2,\r\n                                                 scaledPenRadius, scaledPenRadius));\r\n        draw();\r\n    }\r\n\r\n    /**\r\n     * Draws a circle of the specified radius, centered at (<em>x</em>, <em>y</em>).\r\n     *\r\n     * @param  x the <em>x</em>-coordinate of the center of the circle\r\n     * @param  y the <em>y</em>-coordinate of the center of the circle\r\n     * @param  radius the radius of the circle\r\n     * @throws IllegalArgumentException if {@code radius} is negative\r\n     * @throws IllegalArgumentException if any argument is either NaN or infinite\r\n     */\r\n    public static void circle(double x, double y, double radius) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n        validate(radius, \"radius\");\r\n        validateNonnegative(radius, \"radius\");\r\n\r\n        double xs = scaleX(x);\r\n        double ys = scaleY(y);\r\n        double ws = factorX(2*radius);\r\n        double hs = factorY(2*radius);\r\n        if (ws <= 1 && hs <= 1) pixel(x, y);\r\n        else offscreen.draw(new Ellipse2D.Double(xs - ws/2, ys - hs/2, ws, hs));\r\n        draw();\r\n    }\r\n\r\n    /**\r\n     * Draws a filled circle of the specified radius, centered at (<em>x</em>, <em>y</em>).\r\n     *\r\n     * @param  x the <em>x</em>-coordinate of the center of the circle\r\n     * @param  y the <em>y</em>-coordinate of the center of the circle\r\n     * @param  radius the radius of the circle\r\n     * @throws IllegalArgumentException if {@code radius} is negative\r\n     * @throws IllegalArgumentException if any argument is either NaN or infinite\r\n     */\r\n    public static void filledCircle(double x, double y, double radius) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n        validate(radius, \"radius\");\r\n        validateNonnegative(radius, \"radius\");\r\n\r\n        double xs = scaleX(x);\r\n        double ys = scaleY(y);\r\n        double ws = factorX(2*radius);\r\n        double hs = factorY(2*radius);\r\n        if (ws <= 1 && hs <= 1) pixel(x, y);\r\n        else offscreen.fill(new Ellipse2D.Double(xs - ws/2, ys - hs/2, ws, hs));\r\n        draw();\r\n    }\r\n\r\n\r\n    /**\r\n     * Draws an ellipse with the specified semimajor and semiminor axes,\r\n     * centered at (<em>x</em>, <em>y</em>).\r\n     *\r\n     * @param  x the <em>x</em>-coordinate of the center of the ellipse\r\n     * @param  y the <em>y</em>-coordinate of the center of the ellipse\r\n     * @param  semiMajorAxis is the semimajor axis of the ellipse\r\n     * @param  semiMinorAxis is the semiminor axis of the ellipse\r\n     * @throws IllegalArgumentException if either {@code semiMajorAxis}\r\n     *         or {@code semiMinorAxis} is negative\r\n     * @throws IllegalArgumentException if any argument is either NaN or infinite\r\n     */\r\n    public static void ellipse(double x, double y, double semiMajorAxis, double semiMinorAxis) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n        validate(semiMajorAxis, \"semimajor axis\");\r\n        validate(semiMinorAxis, \"semiminor axis\");\r\n        validateNonnegative(semiMajorAxis, \"semimajor axis\");\r\n        validateNonnegative(semiMinorAxis, \"semiminor axis\");\r\n\r\n        double xs = scaleX(x);\r\n        double ys = scaleY(y);\r\n        double ws = factorX(2*semiMajorAxis);\r\n        double hs = factorY(2*semiMinorAxis);\r\n        if (ws <= 1 && hs <= 1) pixel(x, y);\r\n        else offscreen.draw(new Ellipse2D.Double(xs - ws/2, ys - hs/2, ws, hs));\r\n        draw();\r\n    }\r\n\r\n    /**\r\n     * Draws a filled ellipse with the specified semimajor and semiminor axes,\r\n     * centered at (<em>x</em>, <em>y</em>).\r\n     *\r\n     * @param  x the <em>x</em>-coordinate of the center of the ellipse\r\n     * @param  y the <em>y</em>-coordinate of the center of the ellipse\r\n     * @param  semiMajorAxis is the semimajor axis of the ellipse\r\n     * @param  semiMinorAxis is the semiminor axis of the ellipse\r\n     * @throws IllegalArgumentException if either {@code semiMajorAxis}\r\n     *         or {@code semiMinorAxis} is negative\r\n     * @throws IllegalArgumentException if any argument is either NaN or infinite\r\n     */\r\n    public static void filledEllipse(double x, double y, double semiMajorAxis, double semiMinorAxis) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n        validate(semiMajorAxis, \"semimajor axis\");\r\n        validate(semiMinorAxis, \"semiminor axis\");\r\n        validateNonnegative(semiMajorAxis, \"semimajor axis\");\r\n        validateNonnegative(semiMinorAxis, \"semiminor axis\");\r\n\r\n        double xs = scaleX(x);\r\n        double ys = scaleY(y);\r\n        double ws = factorX(2*semiMajorAxis);\r\n        double hs = factorY(2*semiMinorAxis);\r\n        if (ws <= 1 && hs <= 1) pixel(x, y);\r\n        else offscreen.fill(new Ellipse2D.Double(xs - ws/2, ys - hs/2, ws, hs));\r\n        draw();\r\n    }\r\n\r\n\r\n    /**\r\n     * Draws a circular arc of the specified radius,\r\n     * centered at (<em>x</em>, <em>y</em>), from angle1 to angle2 (in degrees).\r\n     *\r\n     * @param  x the <em>x</em>-coordinate of the center of the circle\r\n     * @param  y the <em>y</em>-coordinate of the center of the circle\r\n     * @param  radius the radius of the circle\r\n     * @param  angle1 the starting angle. 0 would mean an arc beginning at 3 o'clock.\r\n     * @param  angle2 the angle at the end of the arc. For example, if\r\n     *         you want a 90 degree arc, then angle2 should be angle1 + 90.\r\n     * @throws IllegalArgumentException if {@code radius} is negative\r\n     * @throws IllegalArgumentException if any argument is either NaN or infinite\r\n     */\r\n    public static void arc(double x, double y, double radius, double angle1, double angle2) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n        validate(radius, \"arc radius\");\r\n        validate(angle1, \"angle1\");\r\n        validate(angle2, \"angle2\");\r\n        validateNonnegative(radius, \"arc radius\");\r\n\r\n        while (angle2 < angle1) angle2 += 360;\r\n        double xs = scaleX(x);\r\n        double ys = scaleY(y);\r\n        double ws = factorX(2*radius);\r\n        double hs = factorY(2*radius);\r\n        if (ws <= 1 && hs <= 1) pixel(x, y);\r\n        else offscreen.draw(new Arc2D.Double(xs - ws/2, ys - hs/2, ws, hs, angle1, angle2 - angle1, Arc2D.OPEN));\r\n        draw();\r\n    }\r\n\r\n    /**\r\n     * Draws a square of the specified size, centered at (<em>x</em>, <em>y</em>).\r\n     *\r\n     * @param  x the <em>x</em>-coordinate of the center of the square\r\n     * @param  y the <em>y</em>-coordinate of the center of the square\r\n     * @param  halfLength one half the length of any side of the square\r\n     * @throws IllegalArgumentException if {@code halfLength} is negative\r\n     * @throws IllegalArgumentException if any argument is either NaN or infinite\r\n     */\r\n    public static void square(double x, double y, double halfLength) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n        validate(halfLength, \"halfLength\");\r\n        validateNonnegative(halfLength, \"half length\");\r\n\r\n        double xs = scaleX(x);\r\n        double ys = scaleY(y);\r\n        double ws = factorX(2*halfLength);\r\n        double hs = factorY(2*halfLength);\r\n        if (ws <= 1 && hs <= 1) pixel(x, y);\r\n        else offscreen.draw(new Rectangle2D.Double(xs - ws/2, ys - hs/2, ws, hs));\r\n        draw();\r\n    }\r\n\r\n    /**\r\n     * Draws a filled square of the specified size, centered at (<em>x</em>, <em>y</em>).\r\n     *\r\n     * @param  x the <em>x</em>-coordinate of the center of the square\r\n     * @param  y the <em>y</em>-coordinate of the center of the square\r\n     * @param  halfLength one half the length of any side of the square\r\n     * @throws IllegalArgumentException if {@code halfLength} is negative\r\n     * @throws IllegalArgumentException if any argument is either NaN or infinite\r\n     */\r\n    public static void filledSquare(double x, double y, double halfLength) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n        validate(halfLength, \"halfLength\");\r\n        validateNonnegative(halfLength, \"half length\");\r\n\r\n        double xs = scaleX(x);\r\n        double ys = scaleY(y);\r\n        double ws = factorX(2*halfLength);\r\n        double hs = factorY(2*halfLength);\r\n        if (ws <= 1 && hs <= 1) pixel(x, y);\r\n        else offscreen.fill(new Rectangle2D.Double(xs - ws/2, ys - hs/2, ws, hs));\r\n        draw();\r\n    }\r\n\r\n\r\n    /**\r\n     * Draws a rectangle of the specified size, centered at (<em>x</em>, <em>y</em>).\r\n     *\r\n     * @param  x the <em>x</em>-coordinate of the center of the rectangle\r\n     * @param  y the <em>y</em>-coordinate of the center of the rectangle\r\n     * @param  halfWidth one half the width of the rectangle\r\n     * @param  halfHeight one half the height of the rectangle\r\n     * @throws IllegalArgumentException if either {@code halfWidth} or {@code halfHeight} is negative\r\n     * @throws IllegalArgumentException if any argument is either NaN or infinite\r\n     */\r\n    public static void rectangle(double x, double y, double halfWidth, double halfHeight) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n        validate(halfWidth, \"halfWidth\");\r\n        validate(halfHeight, \"halfHeight\");\r\n        validateNonnegative(halfWidth, \"half width\");\r\n        validateNonnegative(halfHeight, \"half height\");\r\n\r\n        double xs = scaleX(x);\r\n        double ys = scaleY(y);\r\n        double ws = factorX(2*halfWidth);\r\n        double hs = factorY(2*halfHeight);\r\n        if (ws <= 1 && hs <= 1) pixel(x, y);\r\n        else offscreen.draw(new Rectangle2D.Double(xs - ws/2, ys - hs/2, ws, hs));\r\n        draw();\r\n    }\r\n\r\n    /**\r\n     * Draws a filled rectangle of the specified size, centered at (<em>x</em>, <em>y</em>).\r\n     *\r\n     * @param  x the <em>x</em>-coordinate of the center of the rectangle\r\n     * @param  y the <em>y</em>-coordinate of the center of the rectangle\r\n     * @param  halfWidth one half the width of the rectangle\r\n     * @param  halfHeight one half the height of the rectangle\r\n     * @throws IllegalArgumentException if either {@code halfWidth} or {@code halfHeight} is negative\r\n     * @throws IllegalArgumentException if any argument is either NaN or infinite\r\n     */\r\n    public static void filledRectangle(double x, double y, double halfWidth, double halfHeight) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n        validate(halfWidth, \"halfWidth\");\r\n        validate(halfHeight, \"halfHeight\");\r\n        validateNonnegative(halfWidth, \"half width\");\r\n        validateNonnegative(halfHeight, \"half height\");\r\n\r\n        double xs = scaleX(x);\r\n        double ys = scaleY(y);\r\n        double ws = factorX(2*halfWidth);\r\n        double hs = factorY(2*halfHeight);\r\n        if (ws <= 1 && hs <= 1) pixel(x, y);\r\n        else offscreen.fill(new Rectangle2D.Double(xs - ws/2, ys - hs/2, ws, hs));\r\n        draw();\r\n    }\r\n\r\n\r\n    /**\r\n     * Draws a polygon with the vertices\r\n     * (<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>),\r\n     * (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>), ...,\r\n     * (<em>x</em><sub><em>n</em>-1</sub>, <em>y</em><sub><em>n</em>-1</sub>).\r\n     *\r\n     * @param  x an array of all the <em>x</em>-coordinates of the polygon\r\n     * @param  y an array of all the <em>y</em>-coordinates of the polygon\r\n     * @throws IllegalArgumentException unless {@code x[]} and {@code y[]}\r\n     *         are of the same length\r\n     * @throws IllegalArgumentException if any coordinate is either NaN or infinite\r\n     * @throws IllegalArgumentException if either {@code x[]} or {@code y[]} is {@code null}\r\n     */\r\n    public static void polygon(double[] x, double[] y) {\r\n        validateNotNull(x, \"x-coordinate array\");\r\n        validateNotNull(y, \"y-coordinate array\");\r\n        for (int i = 0; i < x.length; i++) validate(x[i], \"x[\" + i + \"]\");\r\n        for (int i = 0; i < y.length; i++) validate(y[i], \"y[\" + i + \"]\");\r\n\r\n        int n1 = x.length;\r\n        int n2 = y.length;\r\n        if (n1 != n2) throw new IllegalArgumentException(\"arrays must be of the same length\");\r\n        int n = n1;\r\n        if (n == 0) return;\r\n\r\n        GeneralPath path = new GeneralPath();\r\n        path.moveTo((float) scaleX(x[0]), (float) scaleY(y[0]));\r\n        for (int i = 0; i < n; i++)\r\n            path.lineTo((float) scaleX(x[i]), (float) scaleY(y[i]));\r\n        path.closePath();\r\n        offscreen.draw(path);\r\n        draw();\r\n    }\r\n\r\n    /**\r\n     * Draws a filled polygon with the vertices\r\n     * (<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>),\r\n     * (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>), ...,\r\n     * (<em>x</em><sub><em>n</em>-1</sub>, <em>y</em><sub><em>n</em>-1</sub>).\r\n     *\r\n     * @param  x an array of all the <em>x</em>-coordinates of the polygon\r\n     * @param  y an array of all the <em>y</em>-coordinates of the polygon\r\n     * @throws IllegalArgumentException unless {@code x[]} and {@code y[]}\r\n     *         are of the same length\r\n     * @throws IllegalArgumentException if any coordinate is either NaN or infinite\r\n     * @throws IllegalArgumentException if either {@code x[]} or {@code y[]} is {@code null}\r\n     */\r\n    public static void filledPolygon(double[] x, double[] y) {\r\n        validateNotNull(x, \"x-coordinate array\");\r\n        validateNotNull(y, \"y-coordinate array\");\r\n        for (int i = 0; i < x.length; i++) validate(x[i], \"x[\" + i + \"]\");\r\n        for (int i = 0; i < y.length; i++) validate(y[i], \"y[\" + i + \"]\");\r\n\r\n        int n1 = x.length;\r\n        int n2 = y.length;\r\n        if (n1 != n2) throw new IllegalArgumentException(\"arrays must be of the same length\");\r\n        int n = n1;\r\n        if (n == 0) return;\r\n\r\n        GeneralPath path = new GeneralPath();\r\n        path.moveTo((float) scaleX(x[0]), (float) scaleY(y[0]));\r\n        for (int i = 0; i < n; i++)\r\n            path.lineTo((float) scaleX(x[i]), (float) scaleY(y[i]));\r\n        path.closePath();\r\n        offscreen.fill(path);\r\n        draw();\r\n    }\r\n\r\n\r\n   /***************************************************************************\r\n    *  Drawing images.\r\n    ***************************************************************************/\r\n    // get an image from the given filename\r\n    private static Image getImage(String filename) {\r\n        if (filename == null) throw new IllegalArgumentException();\r\n\r\n        // to read from file\r\n        ImageIcon icon = new ImageIcon(filename);\r\n\r\n        // try to read from URL\r\n        if ((icon == null) || (icon.getImageLoadStatus() != MediaTracker.COMPLETE)) {\r\n            try {\r\n                URL url = new URL(filename);\r\n                icon = new ImageIcon(url);\r\n            }\r\n            catch (MalformedURLException e) {\r\n                /* not a url */\r\n            }\r\n        }\r\n\r\n        // in case file is inside a .jar (classpath relative to StdDraw)\r\n        if ((icon == null) || (icon.getImageLoadStatus() != MediaTracker.COMPLETE)) {\r\n            URL url = StdDraw.class.getResource(filename);\r\n            if (url != null)\r\n                icon = new ImageIcon(url);\r\n        }\r\n\r\n        // in case file is inside a .jar (classpath relative to root of jar)\r\n        if ((icon == null) || (icon.getImageLoadStatus() != MediaTracker.COMPLETE)) {\r\n            URL url = StdDraw.class.getResource(\"/\" + filename);\r\n            if (url == null) throw new IllegalArgumentException(\"image \" + filename + \" not found\");\r\n            icon = new ImageIcon(url);\r\n        }\r\n\r\n        return icon.getImage();\r\n    }\r\n\r\n   /***************************************************************************\r\n    * [Summer 2016] Should we update to use ImageIO instead of ImageIcon()?\r\n    *               Seems to have some issues loading images on some systems\r\n    *               and slows things down on other systems.\r\n    *               especially if you don't call ImageIO.setUseCache(false)\r\n    *               One advantage is that it returns a BufferedImage.\r\n    ***************************************************************************/\r\n/*\r\n    private static BufferedImage getImage(String filename) {\r\n        if (filename == null) throw new IllegalArgumentException();\r\n\r\n        // from a file or URL\r\n        try {\r\n            URL url = new URL(filename);\r\n            BufferedImage image = ImageIO.read(url);\r\n            return image;\r\n        }\r\n        catch (IOException e) {\r\n            // ignore\r\n        }\r\n\r\n        // in case file is inside a .jar (classpath relative to StdDraw)\r\n        try {\r\n            URL url = StdDraw.class.getResource(filename);\r\n            BufferedImage image = ImageIO.read(url);\r\n            return image;\r\n        }\r\n        catch (IOException e) {\r\n            // ignore\r\n        }\r\n\r\n        // in case file is inside a .jar (classpath relative to root of jar)\r\n        try {\r\n            URL url = StdDraw.class.getResource(\"/\" + filename);\r\n            BufferedImage image = ImageIO.read(url);\r\n            return image;\r\n        }\r\n        catch (IOException e) {\r\n            // ignore\r\n        }\r\n        throw new IllegalArgumentException(\"image \" + filename + \" not found\");\r\n    }\r\n*/\r\n    /**\r\n     * Draws the specified image centered at (<em>x</em>, <em>y</em>).\r\n     * The supported image formats are typically JPEG, PNG, GIF TIFF, and BMP.\r\n     * As an optimization, the picture is cached, so there is no performance\r\n     * penalty for redrawing the same image multiple times (e.g., in an animation).\r\n     * However, if you change the picture file after drawing it, subsequent\r\n     * calls will draw the original picture.\r\n     *\r\n     * @param  x the center <em>x</em>-coordinate of the image\r\n     * @param  y the center <em>y</em>-coordinate of the image\r\n     * @param  filename the name of the image/picture, e.g., \"ball.gif\"\r\n     * @throws IllegalArgumentException if the image filename is invalid\r\n     * @throws IllegalArgumentException if either {@code x} or {@code y} is either NaN or infinite\r\n     */\r\n    public static void picture(double x, double y, String filename) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n        validateNotNull(filename, \"filename\");\r\n\r\n        // BufferedImage image = getImage(filename);\r\n        Image image = getImage(filename);\r\n        double xs = scaleX(x);\r\n        double ys = scaleY(y);\r\n        // int ws = image.getWidth();    // can call only if image is a BufferedImage\r\n        // int hs = image.getHeight();\r\n        int ws = image.getWidth(null);\r\n        int hs = image.getHeight(null);\r\n        if (ws < 0 || hs < 0) throw new IllegalArgumentException(\"image \" + filename + \" is corrupt\");\r\n\r\n        offscreen.drawImage(image, (int) Math.round(xs - ws/2.0), (int) Math.round(ys - hs/2.0), null);\r\n        draw();\r\n    }\r\n\r\n    /**\r\n     * Draws the specified image centered at (<em>x</em>, <em>y</em>),\r\n     * rotated given number of degrees.\r\n     * The supported image formats are typically JPEG, PNG, GIF TIFF, and BMP.\r\n     *\r\n     * @param  x the center <em>x</em>-coordinate of the image\r\n     * @param  y the center <em>y</em>-coordinate of the image\r\n     * @param  filename the name of the image/picture, e.g., \"ball.gif\"\r\n     * @param  degrees is the number of degrees to rotate counterclockwise\r\n     * @throws IllegalArgumentException if the image filename is invalid\r\n     * @throws IllegalArgumentException if {@code x}, {@code y}, {@code degrees} is NaN or infinite\r\n     * @throws IllegalArgumentException if {@code filename} is {@code null}\r\n     */\r\n    public static void picture(double x, double y, String filename, double degrees) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n        validate(degrees, \"degrees\");\r\n        validateNotNull(filename, \"filename\");\r\n\r\n        // BufferedImage image = getImage(filename);\r\n        Image image = getImage(filename);\r\n        double xs = scaleX(x);\r\n        double ys = scaleY(y);\r\n        // int ws = image.getWidth();    // can call only if image is a BufferedImage\r\n        // int hs = image.getHeight();\r\n        int ws = image.getWidth(null);\r\n        int hs = image.getHeight(null);\r\n        if (ws < 0 || hs < 0) throw new IllegalArgumentException(\"image \" + filename + \" is corrupt\");\r\n\r\n        offscreen.rotate(Math.toRadians(-degrees), xs, ys);\r\n        offscreen.drawImage(image, (int) Math.round(xs - ws/2.0), (int) Math.round(ys - hs/2.0), null);\r\n        offscreen.rotate(Math.toRadians(+degrees), xs, ys);\r\n\r\n        draw();\r\n    }\r\n\r\n    /**\r\n     * Draws the specified image centered at (<em>x</em>, <em>y</em>),\r\n     * rescaled to the specified bounding box.\r\n     * The supported image formats are typically JPEG, PNG, GIF TIFF, and BMP.\r\n     *\r\n     * @param  x the center <em>x</em>-coordinate of the image\r\n     * @param  y the center <em>y</em>-coordinate of the image\r\n     * @param  filename the name of the image/picture, e.g., \"ball.gif\"\r\n     * @param  scaledWidth the width of the scaled image (in screen coordinates)\r\n     * @param  scaledHeight the height of the scaled image (in screen coordinates)\r\n     * @throws IllegalArgumentException if either {@code scaledWidth}\r\n     *         or {@code scaledHeight} is negative\r\n     * @throws IllegalArgumentException if the image filename is invalid\r\n     * @throws IllegalArgumentException if {@code x} or {@code y} is either NaN or infinite\r\n     * @throws IllegalArgumentException if {@code filename} is {@code null}\r\n     */\r\n    public static void picture(double x, double y, String filename, double scaledWidth, double scaledHeight) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n        validate(scaledWidth, \"scaled width\");\r\n        validate(scaledHeight, \"scaled height\");\r\n        validateNotNull(filename, \"filename\");\r\n        validateNonnegative(scaledWidth, \"scaled width\");\r\n        validateNonnegative(scaledHeight, \"scaled height\");\r\n\r\n        Image image = getImage(filename);\r\n        double xs = scaleX(x);\r\n        double ys = scaleY(y);\r\n        double ws = factorX(scaledWidth);\r\n        double hs = factorY(scaledHeight);\r\n        if (ws < 0 || hs < 0) throw new IllegalArgumentException(\"image \" + filename + \" is corrupt\");\r\n        if (ws <= 1 && hs <= 1) pixel(x, y);\r\n        else {\r\n            offscreen.drawImage(image, (int) Math.round(xs - ws/2.0),\r\n                                       (int) Math.round(ys - hs/2.0),\r\n                                       (int) Math.round(ws),\r\n                                       (int) Math.round(hs), null);\r\n        }\r\n        draw();\r\n    }\r\n\r\n\r\n    /**\r\n     * Draws the specified image centered at (<em>x</em>, <em>y</em>), rotated\r\n     * given number of degrees, and rescaled to the specified bounding box.\r\n     * The supported image formats are typically JPEG, PNG, GIF TIFF, and BMP.\r\n     *\r\n     * @param  x the center <em>x</em>-coordinate of the image\r\n     * @param  y the center <em>y</em>-coordinate of the image\r\n     * @param  filename the name of the image/picture, e.g., \"ball.gif\"\r\n     * @param  scaledWidth the width of the scaled image (in screen coordinates)\r\n     * @param  scaledHeight the height of the scaled image (in screen coordinates)\r\n     * @param  degrees is the number of degrees to rotate counterclockwise\r\n     * @throws IllegalArgumentException if either {@code scaledWidth}\r\n     *         or {@code scaledHeight} is negative\r\n     * @throws IllegalArgumentException if the image filename is invalid\r\n     */\r\n    public static void picture(double x, double y, String filename, double scaledWidth, double scaledHeight, double degrees) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n        validate(scaledWidth, \"scaled width\");\r\n        validate(scaledHeight, \"scaled height\");\r\n        validate(degrees, \"degrees\");\r\n        validateNotNull(filename, \"filename\");\r\n        validateNonnegative(scaledWidth, \"scaled width\");\r\n        validateNonnegative(scaledHeight, \"scaled height\");\r\n\r\n        Image image = getImage(filename);\r\n        double xs = scaleX(x);\r\n        double ys = scaleY(y);\r\n        double ws = factorX(scaledWidth);\r\n        double hs = factorY(scaledHeight);\r\n        if (ws < 0 || hs < 0) throw new IllegalArgumentException(\"image \" + filename + \" is corrupt\");\r\n        if (ws <= 1 && hs <= 1) pixel(x, y);\r\n\r\n        offscreen.rotate(Math.toRadians(-degrees), xs, ys);\r\n        offscreen.drawImage(image, (int) Math.round(xs - ws/2.0),\r\n                                   (int) Math.round(ys - hs/2.0),\r\n                                   (int) Math.round(ws),\r\n                                   (int) Math.round(hs), null);\r\n        offscreen.rotate(Math.toRadians(+degrees), xs, ys);\r\n\r\n        draw();\r\n    }\r\n\r\n   /***************************************************************************\r\n    *  Drawing text.\r\n    ***************************************************************************/\r\n\r\n    /**\r\n     * Writes the given text string in the current font, centered at (<em>x</em>, <em>y</em>).\r\n     *\r\n     * @param  x the center <em>x</em>-coordinate of the text\r\n     * @param  y the center <em>y</em>-coordinate of the text\r\n     * @param  text the text to write\r\n     * @throws IllegalArgumentException if {@code text} is {@code null}\r\n     * @throws IllegalArgumentException if {@code x} or {@code y} is either NaN or infinite\r\n     */\r\n    public static void text(double x, double y, String text) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n        validateNotNull(text, \"text\");\r\n\r\n        offscreen.setFont(font);\r\n        FontMetrics metrics = offscreen.getFontMetrics();\r\n        double xs = scaleX(x);\r\n        double ys = scaleY(y);\r\n        int ws = metrics.stringWidth(text);\r\n        int hs = metrics.getDescent();\r\n        offscreen.drawString(text, (float) (xs - ws/2.0), (float) (ys + hs));\r\n        draw();\r\n    }\r\n\r\n    /**\r\n     * Writes the given text string in the current font, centered at (<em>x</em>, <em>y</em>) and\r\n     * rotated by the specified number of degrees.\r\n     * @param  x the center <em>x</em>-coordinate of the text\r\n     * @param  y the center <em>y</em>-coordinate of the text\r\n     * @param  text the text to write\r\n     * @param  degrees is the number of degrees to rotate counterclockwise\r\n     * @throws IllegalArgumentException if {@code text} is {@code null}\r\n     * @throws IllegalArgumentException if {@code x}, {@code y}, or {@code degrees} is either NaN or infinite\r\n     */\r\n    public static void text(double x, double y, String text, double degrees) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n        validate(degrees, \"degrees\");\r\n        validateNotNull(text, \"text\");\r\n\r\n        double xs = scaleX(x);\r\n        double ys = scaleY(y);\r\n        offscreen.rotate(Math.toRadians(-degrees), xs, ys);\r\n        text(x, y, text);\r\n        offscreen.rotate(Math.toRadians(+degrees), xs, ys);\r\n    }\r\n\r\n\r\n    /**\r\n     * Writes the given text string in the current font, left-aligned at (<em>x</em>, <em>y</em>).\r\n     * @param  x the <em>x</em>-coordinate of the text\r\n     * @param  y the <em>y</em>-coordinate of the text\r\n     * @param  text the text\r\n     * @throws IllegalArgumentException if {@code text} is {@code null}\r\n     * @throws IllegalArgumentException if {@code x} or {@code y} is either NaN or infinite\r\n     */\r\n    public static void textLeft(double x, double y, String text) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n        validateNotNull(text, \"text\");\r\n\r\n        offscreen.setFont(font);\r\n        FontMetrics metrics = offscreen.getFontMetrics();\r\n        double xs = scaleX(x);\r\n        double ys = scaleY(y);\r\n        int hs = metrics.getDescent();\r\n        offscreen.drawString(text, (float) xs, (float) (ys + hs));\r\n        draw();\r\n    }\r\n\r\n    /**\r\n     * Writes the given text string in the current font, right-aligned at (<em>x</em>, <em>y</em>).\r\n     *\r\n     * @param  x the <em>x</em>-coordinate of the text\r\n     * @param  y the <em>y</em>-coordinate of the text\r\n     * @param  text the text to write\r\n     * @throws IllegalArgumentException if {@code text} is {@code null}\r\n     * @throws IllegalArgumentException if {@code x} or {@code y} is either NaN or infinite\r\n     */\r\n    public static void textRight(double x, double y, String text) {\r\n        validate(x, \"x\");\r\n        validate(y, \"y\");\r\n        validateNotNull(text, \"text\");\r\n\r\n        offscreen.setFont(font);\r\n        FontMetrics metrics = offscreen.getFontMetrics();\r\n        double xs = scaleX(x);\r\n        double ys = scaleY(y);\r\n        int ws = metrics.stringWidth(text);\r\n        int hs = metrics.getDescent();\r\n        offscreen.drawString(text, (float) (xs - ws), (float) (ys + hs));\r\n        draw();\r\n    }\r\n\r\n\r\n    /**\r\n     * Copies the offscreen buffer to the onscreen buffer, pauses for t milliseconds\r\n     * and enables double buffering.\r\n     * @param t number of milliseconds\r\n     * @deprecated replaced by {@link #enableDoubleBuffering()}, {@link #show()}, and {@link #pause(int t)}\r\n     */\r\n    @Deprecated\r\n    public static void show(int t) {\r\n        validateNonnegative(t, \"t\");\r\n        show();\r\n        pause(t);\r\n        enableDoubleBuffering();\r\n    }\r\n\r\n    /**\r\n     * Pauses for t milliseconds. This method is intended to support computer animations.\r\n     * @param t number of milliseconds\r\n     */\r\n    public static void pause(int t) {\r\n        validateNonnegative(t, \"t\");\r\n        try {\r\n            Thread.sleep(t);\r\n        }\r\n        catch (InterruptedException e) {\r\n            System.out.println(\"Error sleeping\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Copies offscreen buffer to onscreen buffer. There is no reason to call\r\n     * this method unless double buffering is enabled.\r\n     */\r\n    public static void show() {\r\n        onscreen.drawImage(offscreenImage, 0, 0, null);\r\n        frame.repaint();\r\n    }\r\n\r\n    // draw onscreen if defer is false\r\n    private static void draw() {\r\n        if (!defer) show();\r\n    }\r\n\r\n    /**\r\n     * Enables double buffering. All subsequent calls to\r\n     * drawing methods such as {@code line()}, {@code circle()},\r\n     * and {@code square()} will be deferred until the next call\r\n     * to show(). Useful for animations.\r\n     */\r\n    public static void enableDoubleBuffering() {\r\n        defer = true;\r\n    }\r\n\r\n    /**\r\n     * Disables double buffering. All subsequent calls to\r\n     * drawing methods such as {@code line()}, {@code circle()},\r\n     * and {@code square()} will be displayed on screen when called.\r\n     * This is the default.\r\n     */\r\n    public static void disableDoubleBuffering() {\r\n        defer = false;\r\n    }\r\n\r\n\r\n   /***************************************************************************\r\n    *  Save drawing to a file.\r\n    ***************************************************************************/\r\n\r\n    /**\r\n     * Saves the drawing to using the specified filename.\r\n     * The supported image formats are typically JPEG, PNG, GIF TIFF, and BMP.\r\n     *\r\n     * @param  filename the name of the file with one of the required format\r\n     * @throws IllegalArgumentException if {@code filename} is {@code null}\r\n     */\r\n    public static void save(String filename) {\r\n        validateNotNull(filename, \"filename\");\r\n        if (filename.length() == 0) throw new IllegalArgumentException(\"argument to save() is the empty string\");\r\n        File file = new File(filename);\r\n        String suffix = filename.substring(filename.lastIndexOf('.') + 1);\r\n        if (!filename.contains(\".\")) suffix = \"\";\r\n\r\n        try {\r\n            // if the file format supports transparency (such as PNG or GIF)\r\n            if (ImageIO.write(onscreenImage, suffix, file)) return;\r\n\r\n            // if the file format does not support transparency (such as JPEG or BMP)\r\n            BufferedImage saveImage = new BufferedImage(2*width, 2*height, BufferedImage.TYPE_INT_RGB);\r\n            saveImage.createGraphics().drawImage(onscreenImage, 0, 0, Color.WHITE, null);\r\n            if (ImageIO.write(saveImage, suffix, file)) return;\r\n\r\n            // failed to save the file; probably wrong format\r\n            System.out.printf(\"Error: the filetype '%s' is not supported\\n\", suffix);\r\n        }\r\n        catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * This method cannot be called directly.\r\n     */\r\n    @Override\r\n    public void actionPerformed(ActionEvent e) {\r\n        FileDialog chooser = new FileDialog(StdDraw.frame, \"Use a .png or .jpg extension\", FileDialog.SAVE);\r\n        chooser.setVisible(true);\r\n        String filename = chooser.getFile();\r\n        if (filename != null) {\r\n            StdDraw.save(chooser.getDirectory() + File.separator + chooser.getFile());\r\n        }\r\n    }\r\n\r\n\r\n   /***************************************************************************\r\n    *  Mouse interactions.\r\n    ***************************************************************************/\r\n\r\n    /**\r\n     * Returns true if the mouse is being pressed.\r\n     *\r\n     * @return {@code true} if the mouse is being pressed; {@code false} otherwise\r\n     */\r\n    public static boolean isMousePressed() {\r\n        synchronized (mouseLock) {\r\n            return isMousePressed;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mouse is being pressed.\r\n     *\r\n     * @return {@code true} if the mouse is being pressed; {@code false} otherwise\r\n     * @deprecated replaced by {@link #isMousePressed()}\r\n     */\r\n    @Deprecated\r\n    public static boolean mousePressed() {\r\n        synchronized (mouseLock) {\r\n            return isMousePressed;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the <em>x</em>-coordinate of the mouse.\r\n     *\r\n     * @return the <em>x</em>-coordinate of the mouse\r\n     */\r\n    public static double mouseX() {\r\n        synchronized (mouseLock) {\r\n            return mouseX;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the <em>y</em>-coordinate of the mouse.\r\n     *\r\n     * @return <em>y</em>-coordinate of the mouse\r\n     */\r\n    public static double mouseY() {\r\n        synchronized (mouseLock) {\r\n            return mouseY;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * This method cannot be called directly.\r\n     */\r\n    @Override\r\n    public void mouseClicked(MouseEvent e) {\r\n        // this body is intentionally left empty\r\n    }\r\n\r\n    /**\r\n     * This method cannot be called directly.\r\n     */\r\n    @Override\r\n    public void mouseEntered(MouseEvent e) {\r\n        // this body is intentionally left empty\r\n    }\r\n\r\n    /**\r\n     * This method cannot be called directly.\r\n     */\r\n    @Override\r\n    public void mouseExited(MouseEvent e) {\r\n        // this body is intentionally left empty\r\n    }\r\n\r\n    /**\r\n     * This method cannot be called directly.\r\n     */\r\n    @Override\r\n    public void mousePressed(MouseEvent e) {\r\n        synchronized (mouseLock) {\r\n            mouseX = StdDraw.userX(e.getX());\r\n            mouseY = StdDraw.userY(e.getY());\r\n            isMousePressed = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method cannot be called directly.\r\n     */\r\n    @Override\r\n    public void mouseReleased(MouseEvent e) {\r\n        synchronized (mouseLock) {\r\n            isMousePressed = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method cannot be called directly.\r\n     */\r\n    @Override\r\n    public void mouseDragged(MouseEvent e)  {\r\n        synchronized (mouseLock) {\r\n            mouseX = StdDraw.userX(e.getX());\r\n            mouseY = StdDraw.userY(e.getY());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method cannot be called directly.\r\n     */\r\n    @Override\r\n    public void mouseMoved(MouseEvent e) {\r\n        synchronized (mouseLock) {\r\n            mouseX = StdDraw.userX(e.getX());\r\n            mouseY = StdDraw.userY(e.getY());\r\n        }\r\n    }\r\n\r\n\r\n   /***************************************************************************\r\n    *  Keyboard interactions.\r\n    ***************************************************************************/\r\n\r\n    /**\r\n     * Returns true if the user has typed a key (that has not yet been processed).\r\n     *\r\n     * @return {@code true} if the user has typed a key (that has not yet been processed\r\n     *         by {@link #nextKeyTyped()}; {@code false} otherwise\r\n     */\r\n    public static boolean hasNextKeyTyped() {\r\n        synchronized (keyLock) {\r\n            return !keysTyped.isEmpty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the next key that was typed by the user (that your program has not already processed).\r\n     * This method should be preceded by a call to {@link #hasNextKeyTyped()} to ensure\r\n     * that there is a next key to process.\r\n     * This method returns a Unicode character corresponding to the key\r\n     * typed (such as {@code 'a'} or {@code 'A'}).\r\n     * It cannot identify action keys (such as F1 and arrow keys)\r\n     * or modifier keys (such as control).\r\n     *\r\n     * @return the next key typed by the user (that your program has not already processed).\r\n     * @throws NoSuchElementException if there is no remaining key\r\n     */\r\n    public static char nextKeyTyped() {\r\n        synchronized (keyLock) {\r\n            if (keysTyped.isEmpty()) {\r\n                throw new NoSuchElementException(\"your program has already processed all keystrokes\");\r\n            }\r\n            return keysTyped.remove(keysTyped.size() - 1);\r\n            // return keysTyped.removeLast();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given key is being pressed.\r\n     * <p>\r\n     * This method takes the keycode (corresponding to a physical key)\r\n    *  as an argument. It can handle action keys\r\n     * (such as F1 and arrow keys) and modifier keys (such as shift and control).\r\n     * See {@link KeyEvent} for a description of key codes.\r\n     *\r\n     * @param  keycode the key to check if it is being pressed\r\n     * @return {@code true} if {@code keycode} is currently being pressed;\r\n     *         {@code false} otherwise\r\n     */\r\n    public static boolean isKeyPressed(int keycode) {\r\n        synchronized (keyLock) {\r\n            return keysDown.contains(keycode);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * This method cannot be called directly.\r\n     */\r\n    @Override\r\n    public void keyTyped(KeyEvent e) {\r\n        synchronized (keyLock) {\r\n            keysTyped.addFirst(e.getKeyChar());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method cannot be called directly.\r\n     */\r\n    @Override\r\n    public void keyPressed(KeyEvent e) {\r\n        synchronized (keyLock) {\r\n            keysDown.add(e.getKeyCode());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method cannot be called directly.\r\n     */\r\n    @Override\r\n    public void keyReleased(KeyEvent e) {\r\n        synchronized (keyLock) {\r\n            keysDown.remove(e.getKeyCode());\r\n        }\r\n    }\r\n\r\n\r\n   /***************************************************************************\r\n    *  For improved resolution on Mac Retina displays.\r\n    ***************************************************************************/\r\n\r\n    private static class RetinaImageIcon extends ImageIcon {\r\n\r\n        public RetinaImageIcon(Image image) {\r\n            super(image);\r\n        }\r\n\r\n        public int getIconWidth() {\r\n            return super.getIconWidth() / 2;\r\n        }\r\n\r\n        /**\r\n         * Gets the height of the icon.\r\n         *\r\n         * @return the height in pixels of this icon\r\n         */\r\n        public int getIconHeight() {\r\n            return super.getIconHeight() / 2;\r\n        }\r\n\r\n        public synchronized void paintIcon(Component c, Graphics g, int x, int y) {\r\n            Graphics2D g2 = (Graphics2D) g.create();\r\n            g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BICUBIC);\r\n            g2.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);\r\n            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);\r\n            g2.scale(0.5, 0.5);\r\n            super.paintIcon(c, g2, x * 2, y * 2);\r\n            g2.dispose();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Test client.\r\n     *\r\n     * @param args the command-line arguments\r\n     */\r\n    public static void main(String[] args) {\r\n        StdDraw.square(0.2, 0.8, 0.1);\r\n        StdDraw.filledSquare(0.8, 0.8, 0.2);\r\n        StdDraw.circle(0.8, 0.2, 0.2);\r\n\r\n        StdDraw.setPenColor(StdDraw.BOOK_RED);\r\n        StdDraw.setPenRadius(0.02);\r\n        StdDraw.arc(0.8, 0.2, 0.1, 200, 45);\r\n\r\n        // draw a blue diamond\r\n        StdDraw.setPenRadius();\r\n        StdDraw.setPenColor(StdDraw.BOOK_BLUE);\r\n        double[] x = { 0.1, 0.2, 0.3, 0.2 };\r\n        double[] y = { 0.2, 0.3, 0.2, 0.1 };\r\n        StdDraw.filledPolygon(x, y);\r\n\r\n        // text\r\n        StdDraw.setPenColor(StdDraw.RED);\r\n        StdDraw.text(0.2, 0.5, \"black text\");\r\n        StdDraw.setPenColor(StdDraw.PINK);\r\n        StdDraw.text(0.8, 0.8, \"white text\");\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/StdDraw.java b/src/StdDraw.java
--- a/src/StdDraw.java	(revision 83a2fd7782dbe671502e4d6371e64a700678c107)
+++ b/src/StdDraw.java	(date 1669234164205)
@@ -636,9 +636,9 @@
     private static JFrame frame;
 
     // mouse state
-    private static boolean isMousePressed = false;
-    private static double mouseX = 0;
-    private static double mouseY = 0;
+    public static boolean isMousePressed = false;
+    public static double mouseX = 0;
+    public static double mouseY = 0;
 
     // queue of typed key characters
     private static LinkedList<Character> keysTyped;
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"a0ea00df-6bb9-401e-a43d-22f32f3f7352\" name=\"Changes\" comment=\"more pictures\">\r\n      <change beforePath=\"$PROJECT_DIR$/src/Bishop.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/Bishop.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/ChessGame.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/ChessGame.java\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"ExternalProjectsData\">\r\n    <projectState path=\"$PROJECT_DIR$/resources\">\r\n      <ProjectState />\r\n    </projectState>\r\n  </component>\r\n  <component name=\"ExternalProjectsManager\">\r\n    <system id=\"GRADLE\">\r\n      <state>\r\n        <projects_view>\r\n          <tree_state>\r\n            <expand>\r\n              <path>\r\n                <item name=\"\" type=\"6a2764b6:ExternalProjectsStructure$RootNode\" />\r\n                <item name=\"resources\" type=\"f1a62948:ProjectNode\" />\r\n              </path>\r\n            </expand>\r\n            <select />\r\n          </tree_state>\r\n        </projects_view>\r\n      </state>\r\n    </system>\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"2HrR69UwLYwm5y5z9pjvr4aOo2e\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;Project.color&quot;: &quot;5b1b5d&quot;,\r\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,\r\n    &quot;jdk.selected.JAVA_MODULE&quot;: &quot;14&quot;,\r\n    &quot;project.structure.last.edited&quot;: &quot;Modules&quot;,\r\n    &quot;project.structure.proportion&quot;: &quot;0.0&quot;,\r\n    &quot;project.structure.side.proportion&quot;: &quot;0.0&quot;,\r\n    &quot;run.code.analysis.last.selected.profile&quot;: &quot;pProject Default&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"MoveFile.RECENT_KEYS\">\r\n      <recent name=\"C:\\Users\\9258830\\IdeaProjects\\ChessGame\\src\\resources\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"ChessGame\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"ChessGame\" />\r\n      <module name=\"ChessGame\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Application.ChessGame\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"a0ea00df-6bb9-401e-a43d-22f32f3f7352\" name=\"Changes\" comment=\"\" />\r\n      <created>1669041039571</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1669041039571</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"Addd files\">\r\n      <created>1669041082588</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669041082588</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"Structure\">\r\n      <created>1669043212425</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669043212425</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"Bug fixes and remove usused classes\">\r\n      <created>1669130194405</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669130194405</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"Add pictures for king and queen\">\r\n      <created>1669131971227</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669131971227</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"Test\">\r\n      <created>1669225469845</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669225469845</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00006\" summary=\"more pictures\">\r\n      <created>1669230914224</created>\r\n      <option name=\"number\" value=\"00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669230914224</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"7\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"Addd files\" />\r\n    <MESSAGE value=\"Structure\" />\r\n    <MESSAGE value=\"Bug fixes and remove usused classes\" />\r\n    <MESSAGE value=\"Add pictures for king and queen\" />\r\n    <MESSAGE value=\"Test\" />\r\n    <MESSAGE value=\"more pictures\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"more pictures\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 83a2fd7782dbe671502e4d6371e64a700678c107)
+++ b/.idea/workspace.xml	(date 1669234164213)
@@ -4,9 +4,10 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="a0ea00df-6bb9-401e-a43d-22f32f3f7352" name="Changes" comment="more pictures">
-      <change beforePath="$PROJECT_DIR$/src/Bishop.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/Bishop.java" afterDir="false" />
+    <list default="true" id="a0ea00df-6bb9-401e-a43d-22f32f3f7352" name="Changes" comment="Select not working">
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/ChessGame.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/ChessGame.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/StdDraw.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/StdDraw.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -130,14 +131,7 @@
       <option name="project" value="LOCAL" />
       <updated>1669225469845</updated>
     </task>
-    <task id="LOCAL-00006" summary="more pictures">
-      <created>1669230914224</created>
-      <option name="number" value="00006" />
-      <option name="presentableId" value="LOCAL-00006" />
-      <option name="project" value="LOCAL" />
-      <updated>1669230914224</updated>
-    </task>
-    <option name="localTasksCounter" value="7" />
+    <option name="localTasksCounter" value="6" />
     <servers />
   </component>
   <component name="Vcs.Log.Tabs.Properties">
@@ -157,7 +151,6 @@
     <MESSAGE value="Bug fixes and remove usused classes" />
     <MESSAGE value="Add pictures for king and queen" />
     <MESSAGE value="Test" />
-    <MESSAGE value="more pictures" />
-    <option name="LAST_COMMIT_MESSAGE" value="more pictures" />
+    <option name="LAST_COMMIT_MESSAGE" value="Test" />
   </component>
 </project>
\ No newline at end of file
